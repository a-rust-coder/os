#[repr(C, packed)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct BiosParameterBlockCommon {
    /// Jump instruction to boot code. Allowed forms:
    /// [0xEB, 0x??, 0x90]
    /// [0xE9, 0x??, 0x??]
    jmp_boot: [u8; 3],

    /// OEM Name Identifier. Can be any value. Usually indication of what system formatted the
    /// volume.
    oem_name: [u8; 8],

    /// Count of bytes per sector. May take on only the following values: 512, 1024, 2048, 4096.
    bytes_per_sector: u16,

    /// Number of sectors per cluster. Can be any power of 2 greater than 0. Legal values are 1, 2,
    /// 4, 8, 16, 32, 64, 128.
    sectors_per_cluster: u8,

    /// Number of reserved sectors in the reserved region of the volume, starting at the first
    /// sector of the volume. This field is used to align the start if the data area to integral
    /// multiples of the cluster sie with respect to the start of the partition/media.
    ///
    /// Must not be 0 and can be any non-zero value.
    ///
    /// This field should typically be used to align the start of the data area (cluster #2) to the
    /// desired alignment unit, typically cluster size.
    reserved_sectors_count: u16,

    /// The count of file allocation tables (FATs) on the colume. 2 is recommended although 1 is
    /// acceptable.
    number_of_fats: u8,

    /// For FAT12 and FAT16, contains the count of 32B directory entries in the root directory. For
    /// FAT32, must be set to 0. For FAT12 and FAT16, should always specify a count that when
    /// multiplied by 32 results in an even multiple of `bytes_per_sector`. For maximum
    /// compatibility, FAT16 volumes should use the value 512.
    root_directory_entries: u16,

    /// Old 16-bits total count of sectors on the volume. Includes the count of all sectors of the
    /// volume. can be 0, if it is 0, then `total_sectors_32` must be non-zero. For FAT32, must be
    /// 0. For FAT12 and FAT16,contains the sector count, and `total_sectors_32` is 0 if the total
    /// sector count "fits" (< 0x10000).
    total_sectors_16: u16,

    /// Legal values are 0xF0, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE and 0xFF.
    ///
    /// 0xF8 is the standard value for "fixed" (non-removable) media. For removable media, 0xF0 is
    /// frequently used.
    media: u8,

    /// For FAT12 and FAT16, contains number of sectors used by one FAT. On FAT32, must be 0 and
    /// `fat_size_32` contains the sector count.
    fat_size_16: u16,

    /// Used for volumes with geometry (non LBA)
    sectors_per_track: u16,

    /// Used for volumes with geometry (non LBA)
    number_of_heads: u16,

    /// Number of sectors preceding this partition. Generally not relevant.
    hidden_sectors: u32,

    /// Count of sectors of the volume. Can be 0, if it is 0, then `total_sectors_16` must be
    /// non-zero. For FAT12/FAT16 volumes, contains the count of sectors on the volume. For FAT32,
    /// must be non-zero.
    total_sectors_32: u32,
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ExtendedBpb12_16 {
    /// Must be 0x00 or 0x80
    drive_number: u8,

    /// Reserved. Must be 0
    reserved: u8,

    /// Extended boot signature. Set to 0x29 if either of the two following fields are non-zero.
    boot_signature: u8,

    /// Should be generated by combining current date and time into a 32bits value.
    volume_serial_number: u32,

    /// Matches the 11B volume label recorded in the root directory.
    /// When there is no volume label, must be "NO NAME    "
    volume_label: [u8; 11],

    /// Must be one of:
    /// "FAT12   "
    /// "FAT16   "
    /// "FAT     "
    ///
    /// Informational only, does not determine the FAT type.
    file_system_type: [u8; 8],

    /// Boot code. Usually 0 if data only volume.
    boot_code: [u8; 448],

    /// Signature. Must be:
    /// 0x55 at byte offset 510
    /// 0xAA at byte offset 511
    signature: u16,
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ExtendedBpb32 {
    /// The count of sectors occupied by one FAT
    fat_size_32: u32,

    /// Bits 0 ~ 3: zero-based number of actve FAT. Only valid if mirroring is disabled.
    /// Bits 4 ~ 6: reserved.
    /// Bit  7: 
    ///     - 0 means the FAT is mirrored at runtime into all FATs.
    ///     - 1 means only one FAT is active, the one referenced in bits 0 ~ 3.
    /// Bits 8 ~ 16: reserved.
    extra_flags: [u8; 2],

    /// Must be 0.
    filesystem_version: u16,

    /// Cluster number of the first cluster of the root directory.
    ///
    /// Should be 2 or the first usable (not bad) cluster available thereafter.
    root_cluster: u32,

    /// Sector number of FilesystemInfo struct in the reserved area. Usually 1.
    filesystem_info: u16,

    /// If non-zero, indicates the sector number in the reserved area of the volume of a copy of
    /// the boot record.
    backup_boot_sector: u16,

    /// Reserved. Must be 0.
    reserved0: [u8; 12],

    /// Must be 0x00 or 0x80.
    drive_number: u8,

    /// Reserved. Must be 0.
    reserved1: u8,

    /// Extended boot signature. Set to 0x29 if either of the two following fields are non-zero.
    boot_signature: u8,

    /// Should be generated by combining current date and time into a 32bits value.
    volume_serial_number: u32,

    /// Matches the 11B volume label recorded in the root directory.
    /// When there is no volume label, must be "NO NAME    "
    volume_label: [u8; 11],

    /// Must be "FAT32   "
    ///
    /// Informational only, does not determine the FAT type.
    file_system_type: [u8; 8],

    /// Boot code. Usually 0 if data only volume.
    boot_code: [u8; 420],

    /// Signature. Must be:
    /// 0x55 at byte offset 510
    /// 0xAA at byte offset 511
    signature: u16,
}
