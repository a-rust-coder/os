#[repr(C, packed)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct BiosParameterBlockCommon {
    /// Jump instruction to boot code. Allowed forms:
    /// [0xEB, 0x??, 0x90]
    /// [0xE9, 0x??, 0x??]
    jmp_boot: [u8; 3],

    /// OEM Name Identifier. Can be any value. Usually indication of what system formatted the
    /// volume.
    oem_name: [u8; 8],

    /// Count of bytes per sector. May take on only the following values: 512, 1024, 2048, 4096.
    bytes_per_sector: u16,

    /// Number of sectors per cluster. Can be any power of 2 greater than 0. Legal values are 1, 2,
    /// 4, 8, 16, 32, 64, 128.
    sectors_per_cluster: u8,

    /// Number of reserved sectors in the reserved region of the volume, starting at the first
    /// sector of the volume. This field is used to align the start if the data area to integral
    /// multiples of the cluster sie with respect to the start of the partition/media.
    ///
    /// Must not be 0 and can be any non-zero value.
    ///
    /// This field should typically be used to align the start of the data area (cluster #2) to the
    /// desired alignment unit, typically cluster size.
    reserved_sectors_count: u16,

    /// The count of file allocation tables (FATs) on the colume. 2 is recommended although 1 is
    /// acceptable.
    number_of_fats: u8,

    /// For FAT12 and FAT16, contains the count of 32B directory entries in the root directory. For
    /// FAT32, must be set to 0. For FAT12 and FAT16, should always specify a count that when
    /// multiplied by 32 results in an even multiple of `bytes_per_sector`. For maximum
    /// compatibility, FAT16 volumes should use the value 512.
    root_directory_entries: u16,

    /// Old 16-bits total count of sectors on the volume. Includes the count of all sectors of the
    /// volume. can be 0, if it is 0, then `total_sectors_32` must be non-zero. For FAT32, must be
    /// 0. For FAT12 and FAT16,contains the sector count, and `total_sectors_32` is 0 if the total
    /// sector count "fits" (< 0x10000).
    total_sectors_16: u16,

    /// Legal values are 0xF0, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE and 0xFF.
    ///
    /// 0xF8 is the standard value for "fixed" (non-removable) media. For removable media, 0xF0 is
    /// frequently used.
    media: u8,

    /// For FAT12 and FAT16, contains number of sectors used by one FAT. On FAT32, must be 0 and
    /// `fat_size_32` contains the sector count.
    fat_size_16: u16,

    /// Used for volumes with geometry (non LBA)
    sectors_per_track: u16,

    /// Used for volumes with geometry (non LBA)
    number_of_heads: u16,

    /// Number of sectors preceding this partition. Generally not relevant.
    hidden_sectors: u32,

    /// Count of sectors of the volume. Can be 0, if it is 0, then `total_sectors_16` must be
    /// non-zero. For FAT12/FAT16 volumes, contains the count of sectors on the volume. For FAT32,
    /// must be non-zero.
    total_sectors_32: u32,
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ExtendedBpb12_16 {
    /// Must be 0x00 or 0x80
    drive_number: u8,

    /// Reserved. Must be 0
    reserved: u8,

    /// Extended boot signature. Set to 0x29 if either of the two following fields are non-zero.
    boot_signature: u8,

    /// Should be generated by combining current date and time into a 32bits value.
    volume_serial_number: u32,

    /// Matches the 11B volume label recorded in the root directory.
    /// When there is no volume label, must be "NO NAME    "
    volume_label: [u8; 11],

    /// Must be one of:
    /// "FAT12   "
    /// "FAT16   "
    /// "FAT     "
    ///
    /// Informational only, does not determine the FAT type.
    file_system_type: [u8; 8],

    /// Boot code. Usually 0 if data only volume.
    boot_code: [u8; 448],

    /// Signature. Must be:
    /// 0x55 at byte offset 510
    /// 0xAA at byte offset 511
    signature: u16,
}

#[repr(C, packed)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct ExtendedBpb32 {
    /// The count of sectors occupied by one FAT
    fat_size_32: u32,

    /// Bits 0 ~ 3: zero-based number of actve FAT. Only valid if mirroring is disabled.
    /// Bits 4 ~ 6: reserved.
    /// Bit  7:
    ///     - 0 means the FAT is mirrored at runtime into all FATs.
    ///     - 1 means only one FAT is active, the one referenced in bits 0 ~ 3.
    /// Bits 8 ~ 16: reserved.
    extra_flags: [u8; 2],

    /// Must be 0.
    filesystem_version: u16,

    /// Cluster number of the first cluster of the root directory.
    ///
    /// Should be 2 or the first usable (not bad) cluster available thereafter.
    root_cluster: u32,

    /// Sector number of FilesystemInfo struct in the reserved area. Usually 1.
    filesystem_info: u16,

    /// If non-zero, indicates the sector number in the reserved area of the volume of a copy of
    /// the boot record. Must be 0 or 6.
    backup_boot_sector: u16,

    /// Reserved. Must be 0.
    reserved0: [u8; 12],

    /// Must be 0x00 or 0x80.
    drive_number: u8,

    /// Reserved. Must be 0.
    reserved1: u8,

    /// Extended boot signature. Set to 0x29 if either of the two following fields are non-zero.
    boot_signature: u8,

    /// Should be generated by combining current date and time into a 32bits value.
    volume_serial_number: u32,

    /// Matches the 11B volume label recorded in the root directory.
    /// When there is no volume label, must be "NO NAME    "
    volume_label: [u8; 11],

    /// Must be "FAT32   "
    ///
    /// Informational only, does not determine the FAT type.
    file_system_type: [u8; 8],

    /// Boot code. Usually 0 if data only volume.
    boot_code: [u8; 420],

    /// Signature. Must be:
    /// 0x55 at byte offset 510
    /// 0xAA at byte offset 511
    signature: u16,
}

impl From<[u8; 36]> for BiosParameterBlockCommon {
    fn from(value: [u8; 36]) -> Self {
        Self {
            jmp_boot: [value[0], value[1], value[2]],
            oem_name: [
                value[3], value[4], value[5], value[6], value[7], value[8], value[9], value[10],
            ],
            bytes_per_sector: u16::from_le_bytes([value[11], value[12]]),
            sectors_per_cluster: value[13],
            reserved_sectors_count: u16::from_le_bytes([value[14], value[15]]),
            number_of_fats: value[16],
            root_directory_entries: u16::from_le_bytes([value[17], value[18]]),
            total_sectors_16: u16::from_le_bytes([value[19], value[20]]),
            media: value[21],
            fat_size_16: u16::from_le_bytes([value[22], value[23]]),
            sectors_per_track: u16::from_le_bytes([value[24], value[25]]),
            number_of_heads: u16::from_le_bytes([value[26], value[27]]),
            hidden_sectors: u32::from_le_bytes([value[28], value[29], value[30], value[31]]),
            total_sectors_32: u32::from_le_bytes([value[32], value[33], value[34], value[35]]),
        }
    }
}

impl Into<[u8; 36]> for BiosParameterBlockCommon {
    fn into(self) -> [u8; 36] {
        let mut out = [0; 36];

        out[0..3].copy_from_slice(&self.jmp_boot);
        out[3..11].copy_from_slice(&self.oem_name);
        out[11..13].copy_from_slice(&self.bytes_per_sector.to_le_bytes());
        out[13] = self.sectors_per_cluster;
        out[14..16].copy_from_slice(&self.reserved_sectors_count.to_le_bytes());
        out[16] = self.number_of_fats;
        out[17..19].copy_from_slice(&self.root_directory_entries.to_le_bytes());
        out[19..21].copy_from_slice(&self.total_sectors_16.to_le_bytes());
        out[21] = self.media;
        out[22..24].copy_from_slice(&self.fat_size_16.to_le_bytes());
        out[24..26].copy_from_slice(&self.sectors_per_track.to_le_bytes());
        out[26..28].copy_from_slice(&self.number_of_heads.to_le_bytes());
        out[28..32].copy_from_slice(&self.hidden_sectors.to_le_bytes());
        out[32..36].copy_from_slice(&self.total_sectors_32.to_le_bytes());

        out
    }
}

impl From<[u8; 476]> for ExtendedBpb12_16 {
    fn from(value: [u8; 476]) -> Self {
        Self {
            drive_number: value[0],
            reserved: value[1],
            boot_signature: value[2],
            volume_serial_number: u32::from_le_bytes([value[3], value[4], value[5], value[6]]),
            volume_label: {
                let mut volume_label = [0; 11];
                volume_label.copy_from_slice(&value[7..18]);
                volume_label
            },
            file_system_type: {
                let mut fs_type = [0; 8];
                fs_type.copy_from_slice(&value[18..26]);
                fs_type
            },
            boot_code: {
                let mut boot_code = [0; 448];
                boot_code.copy_from_slice(&value[26..474]);
                boot_code
            },
            signature: u16::from_le_bytes([value[474], value[475]]),
        }
    }
}

impl Into<[u8; 476]> for ExtendedBpb12_16 {
    fn into(self) -> [u8; 476] {
        let mut out = [0; 476];

        out[0] = self.drive_number;
        out[1] = self.reserved;
        out[2] = self.boot_signature;
        out[3..7].copy_from_slice(&self.volume_serial_number.to_le_bytes());
        out[7..18].copy_from_slice(&self.volume_label);
        out[18..26].copy_from_slice(&self.file_system_type);
        out[26..474].copy_from_slice(&self.boot_code);
        out[474..476].copy_from_slice(&self.signature.to_le_bytes());

        out
    }
}

impl From<[u8; 476]> for ExtendedBpb32 {
    fn from(value: [u8; 476]) -> Self {
        Self {
            fat_size_32: u32::from_le_bytes([value[0], value[1], value[2], value[3]]),
            extra_flags: [value[4], value[5]],
            filesystem_version: u16::from_le_bytes([value[6], value[7]]),
            root_cluster: u32::from_le_bytes([value[8], value[9], value[10], value[11]]),
            filesystem_info: u16::from_le_bytes([value[12], value[13]]),
            backup_boot_sector: u16::from_le_bytes([value[14], value[15]]),
            reserved0: {
                let mut reserved0 = [0; 12];
                reserved0.copy_from_slice(&value[16..28]);
                reserved0
            },
            drive_number: value[28],
            reserved1: value[29],
            boot_signature: value[30],
            volume_serial_number: u32::from_le_bytes([value[31], value[32], value[33], value[34]]),
            volume_label: {
                let mut volume_label = [0; 11];
                volume_label.copy_from_slice(&value[35..46]);
                volume_label
            },
            file_system_type: {
                let mut file_system_type = [0; 8];
                file_system_type.copy_from_slice(&value[46..54]);
                file_system_type
            },
            boot_code: {
                let mut boot_code = [0; 420];
                boot_code.copy_from_slice(&value[54..474]);
                boot_code
            },
            signature: u16::from_le_bytes([value[474], value[475]]),
        }
    }
}

impl Into<[u8; 476]> for ExtendedBpb32 {
    fn into(self) -> [u8; 476] {
        let mut out = [0; 476];

        out[0..4].copy_from_slice(&self.fat_size_32.to_le_bytes());
        out[4..6].copy_from_slice(&self.extra_flags);
        out[6..8].copy_from_slice(&self.filesystem_version.to_le_bytes());
        out[8..12].copy_from_slice(&self.root_cluster.to_le_bytes());
        out[12..14].copy_from_slice(&self.filesystem_info.to_le_bytes());
        out[14..16].copy_from_slice(&self.backup_boot_sector.to_le_bytes());
        out[16..28].copy_from_slice(&self.reserved0);
        out[28] = self.drive_number;
        out[29] = self.reserved1;
        out[30] = self.boot_signature;
        out[31..35].copy_from_slice(&self.volume_serial_number.to_le_bytes());
        out[35..46].copy_from_slice(&self.volume_label);
        out[46..54].copy_from_slice(&self.file_system_type);
        out[54..474].copy_from_slice(&self.boot_code);
        out[474..476].copy_from_slice(&self.signature.to_le_bytes());

        todo!()
    }
}

impl BiosParameterBlockCommon {
    pub fn is_valid(&self) -> bool {
        self.bytes_per_sector >= 512
            && [1, 2, 4, 8, 16, 32, 64, 128].contains(&self.sectors_per_cluster)
            && self.reserved_sectors_count != 0
            && self.number_of_fats != 0
            && (self.root_directory_entries * 32) % self.bytes_per_sector == 0
            && self.total_sectors_32 + self.total_sectors_16 as u32 != 0
            && (self.total_sectors_32 == 0 || self.total_sectors_16 == 0)
            && (self.media == 0xF0 || self.media >= 0xF8)
    }

    pub fn detect_fat_type(&self) -> Option<FatType> {
        if !self.is_valid() {
            None
        } else {
            // The official specs say to compute:
            // ((self.root_directory_entries * 32) + self.bytes_per_sector - 1)) / self.bytes_per_sector
            //
            // This is to avoid having an invalid value if `root_directory_entries` is invalid.
            // However, `self.is_valid()` already checks that and ensure
            // `self.root_directory_entries % self.bytes_per_sector == 0`
            let root_dir_sectors =
                ((self.root_directory_entries * 32) / self.bytes_per_sector) as usize;
            let fat_size = if self.fat_size_16 != 0 {
                self.fat_size_16 as usize
            } else {
                return Some(FatType::Fat32);
            };
            let total_sectors = (self.total_sectors_16 as usize) | (self.total_sectors_32 as usize);

            let data_sectors = total_sectors
                - (self.reserved_sectors_count as usize
                    + (self.number_of_fats as usize * fat_size)
                    + root_dir_sectors);

            let count_of_clusters = data_sectors / self.sectors_per_cluster as usize;

            Some(match count_of_clusters {
                ..4085 => FatType::Fat12,
                4085..65525 => FatType::Fat16,
                65525.. => FatType::Fat32,
            })
        }
    }
}

impl ExtendedBpb12_16 {
    pub fn is_valid(&self) -> bool {
        self.drive_number & !0x80 == 0
            && self.reserved == 0
            && [*b"FAT12   ", *b"FAT16   ", *b"FAT     "].contains(&self.file_system_type)
            && self.signature == 0xAA55
    }
}

impl ExtendedBpb32 {
    pub fn is_valid(&self) -> bool {
        self.fat_size_32 != 0
            && self.filesystem_version == 0
            && self.root_cluster >= 2
            && (self.backup_boot_sector == 0 || self.backup_boot_sector == 6)
            && self.reserved0 == [0; 12]
            && (self.drive_number & !0x80) == 0
            && self.reserved1 == 0
            && self.file_system_type == *b"FAT32   "
            && self.signature == 0xAA55
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FatType {
    Fat12,
    Fat16,
    Fat32,
}
